{"version":3,"sources":["webpack:///draftjs-to-html.js","webpack:///webpack/bootstrap 9ee549aa59905ceed774","webpack:///./js/index.js","webpack:///./js/block.js","webpack:///./js/common.js","webpack:///./js/list.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","draftToHtml","editorContent","hashtagConfig","directional","customEntityTransform","customColors","html","blocks","entityMap","length","listBlocks","forEach","block","_list","isList","type","push","listHtml","getListMarkup","blockHtml","_block","getBlockMarkup","join","Object","defineProperty","value","default","getBlockTag","blockTypesMapping","getBlockStyle","data","styles","_common","key","getHashtagRanges","blockText","sections","counter","startIndex","text","trigger","separator","substr","indexOf","endIndex","hashtag","offset","getSections","lastOffset","sectionRanges","entityRanges","map","range","concat","sort","s1","s2","r","start","end","entityKey","isAtomicEntityBlock","isEmptyString","getStyleArrayForBlock","inlineStyleRanges","inlineStyles","BOLD","Array","ITALIC","UNDERLINE","STRIKETHROUGH","CODE","SUPERSCRIPT","SUBSCRIPT","COLOR","BGCOLOR","FONTSIZE","FONTFAMILY","i","style","substring","getStylesAtOffset","sameStyleAsPrevious","index","sameStyled","addInlineStyleMarkup","content","getSectionText","chars","ch","addStylePropertyMarkup","styleSection","styleString","fontColor","bgColor","getEntityMarkup","entity","url","target","src","alignment","height","width","getInlineStyleSections","styleSections","section","trimLeadingZeros","sectionText","replacedText","replace","trimTrailingZeros","getStyleTagSectionMarkup","getInlineStyleSectionMarkup","stylePropertySections","styleSectionText","stylePropertySection","getSectionMarkup","entityInlineMarkup","inlineStyleSections","undefined","getBlockInnerMarkup","blockMarkup","blockTag","blockStyle","unstyled","header-one","header-two","header-three","header-four","header-five","header-six","unordered-list-item","ordered-list-item","blockquote","obj","callback","hasOwnProperty","str","trim","blockType","nestedListBlock","previousBlock","nestedBlock","depth"],"mappings":"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","file":"draftjs-to-html.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = draftToHtml;\n\t\n\tvar _block = __webpack_require__(2);\n\t\n\tvar _list = __webpack_require__(4);\n\t\n\t/**\n\t* The function will generate html markup for given draftjs editorContent.\n\t*/\n\t\n\tfunction draftToHtml(editorContent, hashtagConfig, directional, customEntityTransform, customColors) {\n\t  var html = [];\n\t  if (editorContent) {\n\t    (function () {\n\t      var blocks = editorContent.blocks,\n\t          entityMap = editorContent.entityMap;\n\t\n\t      if (blocks && blocks.length > 0) {\n\t        (function () {\n\t          var listBlocks = [];\n\t          blocks.forEach(function (block) {\n\t            if ((0, _list.isList)(block.type)) {\n\t              listBlocks.push(block);\n\t            } else {\n\t              if (listBlocks.length > 0) {\n\t                var listHtml = (0, _list.getListMarkup)(listBlocks, entityMap, hashtagConfig, customEntityTransform, customColors);\n\t                html.push(listHtml);\n\t                listBlocks = [];\n\t              }\n\t              var blockHtml = (0, _block.getBlockMarkup)(block, entityMap, hashtagConfig, directional, customEntityTransform, customColors);\n\t              html.push(blockHtml);\n\t            }\n\t          });\n\t          if (listBlocks.length > 0) {\n\t            var listHtml = (0, _list.getListMarkup)(listBlocks, entityMap, hashtagConfig, customEntityTransform, customColors);\n\t            html.push(listHtml);\n\t            listBlocks = [];\n\t          }\n\t        })();\n\t      }\n\t    })();\n\t  }\n\t  return html.join('');\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getBlockTag = getBlockTag;\n\texports.getBlockStyle = getBlockStyle;\n\texports.getStylesAtOffset = getStylesAtOffset;\n\texports.sameStyleAsPrevious = sameStyleAsPrevious;\n\texports.addInlineStyleMarkup = addInlineStyleMarkup;\n\texports.addStylePropertyMarkup = addStylePropertyMarkup;\n\texports.trimLeadingZeros = trimLeadingZeros;\n\texports.trimTrailingZeros = trimTrailingZeros;\n\texports.getBlockInnerMarkup = getBlockInnerMarkup;\n\texports.getBlockMarkup = getBlockMarkup;\n\t\n\tvar _common = __webpack_require__(3);\n\t\n\t/**\n\t* Mapping block-type to corresponding html tag.\n\t*/\n\tvar blockTypesMapping = {\n\t  unstyled: 'p',\n\t  'header-one': 'h1',\n\t  'header-two': 'h2',\n\t  'header-three': 'h3',\n\t  'header-four': 'h4',\n\t  'header-five': 'h5',\n\t  'header-six': 'h6',\n\t  'unordered-list-item': 'ul',\n\t  'ordered-list-item': 'ol',\n\t  blockquote: 'blockquote'\n\t};\n\t\n\t/**\n\t* Function will return HTML tag for a block.\n\t*/\n\tfunction getBlockTag(type) {\n\t  return type && blockTypesMapping[type];\n\t}\n\t\n\t/**\n\t* Function will return style string for a block.\n\t*/\n\tfunction getBlockStyle(data) {\n\t  var styles = '';\n\t  (0, _common.forEach)(data, function (key, value) {\n\t    if (value) {\n\t      styles += key + ':' + value + ';';\n\t    }\n\t  });\n\t  return styles;\n\t}\n\t\n\t/**\n\t* The function returns an array of hashtag-sections in blocks.\n\t* These will be areas in block which have hashtags applicable to them.\n\t*/\n\tfunction getHashtagRanges(blockText, hashtagConfig) {\n\t  var sections = [];\n\t  if (hashtagConfig) {\n\t    var counter = 0;\n\t    var startIndex = 0;\n\t    var text = blockText;\n\t    var trigger = hashtagConfig.trigger || '#';\n\t    var separator = hashtagConfig.separator || ' ';\n\t    for (; text.length > 0 && startIndex >= 0;) {\n\t      if (text[0] === trigger) {\n\t        startIndex = 0;\n\t        counter = 0;\n\t        text = text.substr(trigger.length);\n\t      } else {\n\t        startIndex = text.indexOf(separator + trigger);\n\t        if (startIndex >= 0) {\n\t          text = text.substr(startIndex + (separator + trigger).length);\n\t          counter += startIndex + separator.length;\n\t        }\n\t      }\n\t      if (startIndex >= 0) {\n\t        var endIndex = text.indexOf(separator) >= 0 ? text.indexOf(separator) : text.length;\n\t        var hashtag = text.substr(0, endIndex);\n\t        if (hashtag && hashtag.length > 0) {\n\t          sections.push({\n\t            offset: counter,\n\t            length: hashtag.length + trigger.length,\n\t            type: 'HASHTAG'\n\t          });\n\t        }\n\t        counter += trigger.length;\n\t      }\n\t    }\n\t  }\n\t  return sections;\n\t}\n\t\n\t/**\n\t* The function returns an array of entity-sections in blocks.\n\t* These will be areas in block which have same entity or no entity applicable to them.\n\t*/\n\tfunction getSections(block, hashtagConfig) {\n\t  var sections = [];\n\t  var lastOffset = 0;\n\t  var sectionRanges = block.entityRanges.map(function (range) {\n\t    var offset = range.offset,\n\t        length = range.length,\n\t        key = range.key;\n\t\n\t    return {\n\t      offset: offset,\n\t      length: length,\n\t      key: key,\n\t      type: 'ENTITY'\n\t    };\n\t  });\n\t  sectionRanges = sectionRanges.concat(getHashtagRanges(block.text, hashtagConfig));\n\t  sectionRanges = sectionRanges.sort(function (s1, s2) {\n\t    return s1.offset - s2.offset;\n\t  });\n\t  sectionRanges.forEach(function (r) {\n\t    if (r.offset > lastOffset) {\n\t      sections.push({\n\t        start: lastOffset,\n\t        end: r.offset\n\t      });\n\t    }\n\t    sections.push({\n\t      start: r.offset,\n\t      end: r.offset + r.length,\n\t      entityKey: r.key,\n\t      type: r.type\n\t    });\n\t    lastOffset = r.offset + r.length;\n\t  });\n\t  if (lastOffset < block.text.length) {\n\t    sections.push({\n\t      start: lastOffset,\n\t      end: block.text.length\n\t    });\n\t  }\n\t  return sections;\n\t}\n\t\n\t/**\n\t* Function to check if the block is an atomic entity block.\n\t*/\n\tfunction isAtomicEntityBlock(block) {\n\t  if (block.entityRanges.length > 0 && (0, _common.isEmptyString)(block.text) || block.type === 'atomic') {\n\t    return true;\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t* The function will return array of inline styles applicable to the block.\n\t*/\n\tfunction getStyleArrayForBlock(block) {\n\t  var text = block.text,\n\t      inlineStyleRanges = block.inlineStyleRanges;\n\t\n\t  var inlineStyles = {\n\t    BOLD: new Array(text.length),\n\t    ITALIC: new Array(text.length),\n\t    UNDERLINE: new Array(text.length),\n\t    STRIKETHROUGH: new Array(text.length),\n\t    CODE: new Array(text.length),\n\t    SUPERSCRIPT: new Array(text.length),\n\t    SUBSCRIPT: new Array(text.length),\n\t    COLOR: new Array(text.length),\n\t    BGCOLOR: new Array(text.length),\n\t    FONTSIZE: new Array(text.length),\n\t    FONTFAMILY: new Array(text.length),\n\t    length: text.length\n\t  };\n\t  if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n\t    inlineStyleRanges.forEach(function (range) {\n\t      var offset = range.offset;\n\t      var length = offset + range.length;\n\t      for (var i = offset; i < length; i += 1) {\n\t        if (range.style.indexOf('color-') === 0) {\n\t          inlineStyles.COLOR[i] = range.style.substring(6);\n\t        } else if (range.style.indexOf('bgcolor-') === 0) {\n\t          inlineStyles.BGCOLOR[i] = range.style.substring(8);\n\t        } else if (range.style.indexOf('fontsize-') === 0) {\n\t          inlineStyles.FONTSIZE[i] = range.style.substring(9);\n\t        } else if (range.style.indexOf('fontfamily-') === 0) {\n\t          inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n\t        } else if (inlineStyles[range.style]) {\n\t          inlineStyles[range.style][i] = true;\n\t        }\n\t      }\n\t    });\n\t  }\n\t\n\t  return inlineStyles;\n\t}\n\t\n\t/**\n\t* The function will return inline style applicable at some offset within a block.\n\t*/\n\tfunction getStylesAtOffset(inlineStyles, offset) {\n\t  var styles = {};\n\t  if (inlineStyles.COLOR[offset]) {\n\t    styles.COLOR = inlineStyles.COLOR[offset];\n\t  }\n\t  if (inlineStyles.BGCOLOR[offset]) {\n\t    styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n\t  }\n\t  if (inlineStyles.FONTSIZE[offset]) {\n\t    styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n\t  }\n\t  if (inlineStyles.FONTFAMILY[offset]) {\n\t    styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n\t  }\n\t  if (inlineStyles.UNDERLINE[offset]) {\n\t    styles.UNDERLINE = true;\n\t  }\n\t  if (inlineStyles.ITALIC[offset]) {\n\t    styles.ITALIC = true;\n\t  }\n\t  if (inlineStyles.BOLD[offset]) {\n\t    styles.BOLD = true;\n\t  }\n\t  if (inlineStyles.STRIKETHROUGH[offset]) {\n\t    styles.STRIKETHROUGH = true;\n\t  }\n\t  if (inlineStyles.CODE[offset]) {\n\t    styles.CODE = true;\n\t  }\n\t  if (inlineStyles.SUBSCRIPT[offset]) {\n\t    styles.SUBSCRIPT = true;\n\t  }\n\t  if (inlineStyles.SUPERSCRIPT[offset]) {\n\t    styles.SUPERSCRIPT = true;\n\t  }\n\t  return styles;\n\t}\n\t\n\t/**\n\t* Function returns true for a set of styles if the value of these styles at an offset\n\t* are same as that on the previous offset.\n\t*/\n\tfunction sameStyleAsPrevious(inlineStyles, styles, index) {\n\t  var sameStyled = true;\n\t  if (index > 0 && index < inlineStyles.length) {\n\t    styles.forEach(function (style) {\n\t      sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n\t    });\n\t  } else {\n\t    sameStyled = false;\n\t  }\n\t  return sameStyled;\n\t}\n\t\n\t/**\n\t* Function returns html for text depending on inline style tags applicable to it.\n\t*/\n\tfunction addInlineStyleMarkup(style, content) {\n\t  if (style === 'BOLD') {\n\t    return '<strong>' + content + '</strong>';\n\t  } else if (style === 'ITALIC') {\n\t    return '<em>' + content + '</em>';\n\t  } else if (style === 'UNDERLINE') {\n\t    return '<ins>' + content + '</ins>';\n\t  } else if (style === 'STRIKETHROUGH') {\n\t    return '<del>' + content + '</del>';\n\t  } else if (style === 'CODE') {\n\t    return '<code>' + content + '</code>';\n\t  } else if (style === 'SUPERSCRIPT') {\n\t    return '<sup>' + content + '</sup>';\n\t  } else if (style === 'SUBSCRIPT') {\n\t    return '<sub>' + content + '</sub>';\n\t  }\n\t  return content;\n\t}\n\t\n\t/**\n\t* The function returns text for given section of block after doing required character replacements.\n\t*/\n\tfunction getSectionText(text) {\n\t\n\t  if (text && text.length > 0) {\n\t    var chars = text.map(function (ch) {\n\t      switch (ch) {\n\t        case '\\n':\n\t          return '<br>\\n';\n\t        case '&':\n\t          return '&amp;';\n\t        case '<':\n\t          return '&lt;';\n\t        case '>':\n\t          return '&gt;';\n\t        default:\n\t          return ch;\n\t      }\n\t    });\n\t    return chars.join('');\n\t  }\n\t  return '';\n\t}\n\t\n\t/**\n\t* Function returns html for text depending on inline style tags applicable to it.\n\t*/\n\tfunction addStylePropertyMarkup(styleSection, customColors) {\n\t  var styles = styleSection.styles,\n\t      text = styleSection.text;\n\t\n\t  var content = getSectionText(text);\n\t  if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n\t    var styleString = 'style=\"';\n\t    if (styles.COLOR) {\n\t      var fontColor = customColors[styles.COLOR];\n\t      styleString += 'color: ' + fontColor + ';';\n\t    }\n\t    if (styles.BGCOLOR) {\n\t      var bgColor = customColors[styles.BGCOLOR];\n\t      styleString += 'background-color: ' + bgColor + ';';\n\t    }\n\t    if (styles.FONTSIZE) {\n\t      styleString += 'font-size: ' + styles.FONTSIZE + 'px;';\n\t    }\n\t    if (styles.FONTFAMILY) {\n\t      styleString += 'font-family: ' + styles.FONTFAMILY + ';';\n\t    }\n\t    styleString += '\"';\n\t    return '<span ' + styleString + '>' + content + '</span>';\n\t  }\n\t  return content;\n\t}\n\t\n\t/**\n\t* Function will return markup for Entity.\n\t*/\n\tfunction getEntityMarkup(entityMap, entityKey, text, customEntityTransform) {\n\t  var entity = entityMap[entityKey];\n\t  if (typeof customEntityTransform === 'function') {\n\t    var html = customEntityTransform(entity, text);\n\t    if (html) {\n\t      return html;\n\t    }\n\t  }\n\t  if (entity.type === 'MENTION') {\n\t    return '<a href=\"' + entity.data.url + '\" class=\"wysiwyg-mention\" data-mention data-value=\"' + entity.data.value + '\">' + text + '</a>';\n\t  }\n\t  if (entity.type === 'LINK') {\n\t    var target = entity.data.target || '_blank';\n\t    return '<a href=\"' + entity.data.url + '\" target=\"' + target + '\" >' + text + '</a>';\n\t  }\n\t  if (entity.type === 'IMAGE') {\n\t    return '<a href=\"' + entity.data.src + '\" target=\"_blank\"><img src=\"' + entity.data.src + '\" style=\"float:' + (entity.data.alignment || 'none') + ';height: ' + entity.data.height + ';width: ' + entity.data.width + '\"/></a>';\n\t  }\n\t  if (entity.type === 'EMBEDDED_LINK') {\n\t    return '<iframe width=\"' + entity.data.width + '\" height=\"' + entity.data.height + '\" src=\"' + entity.data.src + '\" frameBorder=\"0\" allowFullScreen />';\n\t  }\n\t  return text;\n\t}\n\t\n\t/**\n\t* For a given section in a block the function will return a further list of sections,\n\t* with similar inline styles applicable to them.\n\t*/\n\tfunction getInlineStyleSections(block, styles, start, end) {\n\t  var styleSections = [];\n\t  var text = block.text;\n\t\n\t  if (text.length > 0) {\n\t    var inlineStyles = getStyleArrayForBlock(block);\n\t    var section = void 0;\n\t    for (var i = start; i < end; i += 1) {\n\t      if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n\t        section.text.push(text[i]);\n\t        section.end = i + 1;\n\t      } else {\n\t        section = {\n\t          styles: getStylesAtOffset(inlineStyles, i),\n\t          text: [text[i]],\n\t          start: i,\n\t          end: i + 1\n\t        };\n\t        styleSections.push(section);\n\t      }\n\t    }\n\t  }\n\t  return styleSections;\n\t}\n\t\n\t/**\n\t* Replace leading blank spaces by &nbsp;\n\t*/\n\tfunction trimLeadingZeros(sectionText) {\n\t  if (sectionText) {\n\t    var replacedText = sectionText;\n\t    for (var i = 0; i < replacedText.length; i += 1) {\n\t      if (sectionText[i] === ' ') {\n\t        replacedText = replacedText.replace(' ', '&nbsp;');\n\t      } else {\n\t        break;\n\t      }\n\t    }\n\t    return replacedText;\n\t  }\n\t  return sectionText;\n\t}\n\t\n\t/**\n\t* Replace trailing blank spaces by &nbsp;\n\t*/\n\tfunction trimTrailingZeros(sectionText) {\n\t  if (sectionText) {\n\t    var replacedText = sectionText;\n\t    for (var i = replacedText.length - 1; i >= 0; i -= 1) {\n\t      if (replacedText[i] === ' ') {\n\t        replacedText = replacedText.substring(0, i) + '&nbsp;' + replacedText.substring(i + 1);\n\t      } else {\n\t        break;\n\t      }\n\t    }\n\t    return replacedText;\n\t  }\n\t  return sectionText;\n\t}\n\t\n\t/**\n\t* The method returns markup for section to which inline styles\n\t* like BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n\t*/\n\tfunction getStyleTagSectionMarkup(styles, text) {\n\t  var content = text;\n\t  (0, _common.forEach)(styles, function (style, value) {\n\t    content = addInlineStyleMarkup(style, content, value);\n\t  });\n\t  return content;\n\t}\n\t\n\t/**\n\t* The method returns markup for section to which inline styles\n\tlike color, background-color, font-size are applicable.\n\t*/\n\tfunction getInlineStyleSectionMarkup(block, styleSection, customColors) {\n\t  var stylePropertySections = getInlineStyleSections(block, ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'], styleSection.start, styleSection.end);\n\t  var styleSectionText = '';\n\t  stylePropertySections.forEach(function (stylePropertySection) {\n\t    styleSectionText += addStylePropertyMarkup(stylePropertySection, customColors);\n\t  });\n\t  styleSectionText = getStyleTagSectionMarkup(styleSection.styles, styleSectionText);\n\t  return styleSectionText;\n\t}\n\t\n\t/*\n\t* The method returns markup for an entity section.\n\t* An entity section is a continuous section in a block\n\t* to which same entity or no entity is applicable.\n\t*/\n\tfunction getSectionMarkup(block, entityMap, section, customEntityTransform, customColors) {\n\t  var entityInlineMarkup = [];\n\t  var inlineStyleSections = getInlineStyleSections(block, ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'], section.start, section.end);\n\t  inlineStyleSections.forEach(function (styleSection) {\n\t    entityInlineMarkup.push(getInlineStyleSectionMarkup(block, styleSection, customColors));\n\t  });\n\t  var sectionText = entityInlineMarkup.join('');\n\t  if (section.type === 'ENTITY') {\n\t    if (section.entityKey !== undefined && section.entityKey !== null) {\n\t      sectionText = getEntityMarkup(entityMap, section.entityKey, sectionText, customEntityTransform);\n\t    }\n\t  } else if (section.type === 'HASHTAG') {\n\t    sectionText = '<a href=\"' + sectionText + '\" class=\"wysiwyg-hashtag\">' + sectionText + '</a>';\n\t  }\n\t  return sectionText;\n\t}\n\t\n\t/**\n\t* Function will return the markup for block preserving the inline styles and\n\t* special characters like newlines or blank spaces.\n\t*/\n\t\n\tfunction getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform, customColors) {\n\t  var blockMarkup = [];\n\t  var sections = getSections(block, hashtagConfig);\n\t  sections.forEach(function (section, index) {\n\t    var sectionText = getSectionMarkup(block, entityMap, section, customEntityTransform, customColors);\n\t    if (index === 0) {\n\t      sectionText = trimLeadingZeros(sectionText);\n\t    }\n\t    if (index === sections.length - 1) {\n\t      sectionText = trimTrailingZeros(sectionText);\n\t    }\n\t    blockMarkup.push(sectionText);\n\t  });\n\t\n\t  return blockMarkup.join('');\n\t}\n\t\n\t/**\n\t* Function will return html for the block.\n\t*/\n\tfunction getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform, customColors) {\n\t  var blockHtml = [];\n\t  if (isAtomicEntityBlock(block)) {\n\t    blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key, undefined, customEntityTransform));\n\t  } else {\n\t\n\t    var blockTag = getBlockTag(block.type);\n\t\n\t    if (blockTag && block.text) {\n\t      blockHtml.push('<' + blockTag);\n\t      var blockStyle = getBlockStyle(block.data);\n\t      if (blockStyle) {\n\t        blockHtml.push(' style=\"' + blockStyle + '\"');\n\t      }\n\t      if (directional) {\n\t        blockHtml.push(' dir = \"auto\"');\n\t      }\n\t      blockHtml.push('>');\n\t      blockHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform, customColors));\n\t      blockHtml.push('</' + blockTag + '>');\n\t    } else {\n\t      blockHtml.push('<br/>');\n\t    }\n\t  }\n\t  blockHtml.push('\\n');\n\t  return blockHtml.join('');\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.forEach = forEach;\n\texports.isEmptyString = isEmptyString;\n\t\n\t\n\t/**\n\t* Utility function to execute callback for eack key->value pair.\n\t*/\n\tfunction forEach(obj, callback) {\n\t  if (obj) {\n\t    for (var key in obj) {\n\t      // eslint-disable-line no-restricted-syntax\n\t      if ({}.hasOwnProperty.call(obj, key)) {\n\t        callback(key, obj[key]);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t* The function returns true if the string passed to it has no content.\n\t*/\n\tfunction isEmptyString(str) {\n\t  if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n\t    return true;\n\t  }\n\t  return false;\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.isList = isList;\n\texports.getListMarkup = getListMarkup;\n\t\n\tvar _block = __webpack_require__(2);\n\t\n\t/**\n\t* Function to check if a block is of type list.\n\t*/\n\tfunction isList(blockType) {\n\t  return blockType === 'unordered-list-item' || blockType === 'ordered-list-item';\n\t}\n\t\n\t/**\n\t* Function will return html markup for a list block.\n\t*/\n\tfunction getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform) {\n\t  var listHtml = [];\n\t  var nestedListBlock = [];\n\t  var previousBlock = void 0;\n\t  listBlocks.forEach(function (block) {\n\t    var nestedBlock = false;\n\t    if (!previousBlock) {\n\t      listHtml.push('<' + (0, _block.getBlockTag)(block.type) + '>\\n');\n\t    } else if (previousBlock.type !== block.type) {\n\t      listHtml.push('</' + (0, _block.getBlockTag)(previousBlock.type) + '>\\n');\n\t      listHtml.push('<' + (0, _block.getBlockTag)(block.type) + '>\\n');\n\t    } else if (previousBlock.depth === block.depth) {\n\t      if (nestedListBlock && nestedListBlock.length > 0) {\n\t        listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n\t        nestedListBlock = [];\n\t      }\n\t    } else {\n\t      nestedBlock = true;\n\t      nestedListBlock.push(block);\n\t    }\n\t    if (!nestedBlock) {\n\t      listHtml.push('<li');\n\t      var blockStyle = (0, _block.getBlockStyle)(block.data);\n\t      if (blockStyle) {\n\t        listHtml.push(' style=\"' + blockStyle + '\"');\n\t      }\n\t      if (directional) {\n\t        blockHtml.push(' dir = \"auto\"');\n\t      }\n\t      listHtml.push('>');\n\t      listHtml.push((0, _block.getBlockInnerMarkup)(block, entityMap, hashtagConfig, customEntityTransform, customColors));\n\t      listHtml.push('</li>\\n');\n\t      previousBlock = block;\n\t    }\n\t  });\n\t  if (nestedListBlock && nestedListBlock.length > 0) {\n\t    listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n\t  }\n\t  listHtml.push('</' + (0, _block.getBlockTag)(previousBlock.type) + '>\\n');\n\t  return listHtml.join('');\n\t}\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// draftjs-to-html.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9ee549aa59905ceed774","/* @flow */\n\nimport { getBlockMarkup } from './block';\nimport { isList, getListMarkup } from './list';\n\n/**\n* The function will generate html markup for given draftjs editorContent.\n*/\n\nexport default function draftToHtml(\n  editorContent: ContentState,\n  hashtagConfig: Object,\n  directional: boolean,\n  customEntityTransform: Function,\n  customColors: Object\n): string {\n  const html = [];\n  if (editorContent) {\n    const { blocks, entityMap } = editorContent;\n    if (blocks && blocks.length > 0) {\n      let listBlocks = [];\n      blocks.forEach((block) => {\n        if (isList(block.type)) {\n          listBlocks.push(block);\n        } else {\n          if (listBlocks.length > 0) {\n            const listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, customEntityTransform, customColors);\n            html.push(listHtml);\n            listBlocks = [];\n          }\n          const blockHtml = getBlockMarkup(\n            block,\n            entityMap,\n            hashtagConfig,\n            directional,\n            customEntityTransform,\n            customColors\n          );\n          html.push(blockHtml);\n        }\n      });\n      if (listBlocks.length > 0) {\n        const listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, customEntityTransform, customColors);\n        html.push(listHtml);\n        listBlocks = [];\n      }\n    }\n  }\n  return html.join('');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./js/index.js","import { forEach, isEmptyString } from './common';\n\n/**\n* Mapping block-type to corresponding html tag.\n*/\nconst blockTypesMapping: Object = {\n  unstyled: 'p',\n  'header-one': 'h1',\n  'header-two': 'h2',\n  'header-three': 'h3',\n  'header-four': 'h4',\n  'header-five': 'h5',\n  'header-six': 'h6',\n  'unordered-list-item': 'ul',\n  'ordered-list-item': 'ol',\n  blockquote: 'blockquote',\n};\n\n/**\n* Function will return HTML tag for a block.\n*/\nexport function getBlockTag(type: string): string {\n  return type && blockTypesMapping[type];\n}\n\n/**\n* Function will return style string for a block.\n*/\nexport function getBlockStyle(data: Object): string {\n  let styles = '';\n  forEach(data, (key, value) => {\n    if (value) {\n      styles += `${key}:${value};`;\n    }\n  });\n  return styles;\n}\n\n/**\n* The function returns an array of hashtag-sections in blocks.\n* These will be areas in block which have hashtags applicable to them.\n*/\nfunction getHashtagRanges(blockText: string, hashtagConfig: Object): Array<Object> {\n  const sections = [];\n  if (hashtagConfig) {\n    let counter = 0;\n    let startIndex = 0;\n    let text = blockText;\n    const trigger = hashtagConfig.trigger || '#';\n    const separator = hashtagConfig.separator || ' ';\n    for (;text.length > 0 && startIndex >= 0;) {\n      if (text[0] === trigger) {\n        startIndex = 0;\n        counter = 0;\n        text = text.substr(trigger.length);\n      } else {\n        startIndex = text.indexOf(separator + trigger);\n        if (startIndex >= 0) {\n          text = text.substr(startIndex + (separator + trigger).length);\n          counter += startIndex + separator.length;\n        }\n      }\n      if (startIndex >= 0) {\n        const endIndex =\n          text.indexOf(separator) >= 0\n          ? text.indexOf(separator)\n          : text.length;\n        const hashtag = text.substr(0, endIndex);\n        if (hashtag && hashtag.length > 0) {\n          sections.push({\n            offset: counter,\n            length: hashtag.length + trigger.length,\n            type: 'HASHTAG',\n          });\n        }\n        counter += trigger.length;\n      }\n    }\n  }\n  return sections;\n}\n\n/**\n* The function returns an array of entity-sections in blocks.\n* These will be areas in block which have same entity or no entity applicable to them.\n*/\nfunction getSections(\n  block: Object,\n  hashtagConfig: Object\n): Array<Object> {\n  const sections = [];\n  let lastOffset = 0;\n  let sectionRanges = block.entityRanges.map((range) => {\n    const { offset, length, key } = range;\n    return {\n      offset,\n      length,\n      key,\n      type: 'ENTITY',\n    };\n  });\n  sectionRanges = sectionRanges.concat(getHashtagRanges(block.text, hashtagConfig));\n  sectionRanges = sectionRanges.sort((s1, s2) => s1.offset - s2.offset);\n  sectionRanges.forEach((r) => {\n    if (r.offset > lastOffset) {\n      sections.push({\n        start: lastOffset,\n        end: r.offset,\n      });\n    }\n    sections.push({\n      start: r.offset,\n      end: r.offset + r.length,\n      entityKey: r.key,\n      type: r.type,\n    });\n    lastOffset = r.offset + r.length;\n  });\n  if (lastOffset < block.text.length) {\n    sections.push({\n      start: lastOffset,\n      end: block.text.length,\n    });\n  }\n  return sections;\n}\n\n/**\n* Function to check if the block is an atomic entity block.\n*/\nfunction isAtomicEntityBlock(block: Object): boolean {\n  if ((block.entityRanges.length > 0 && isEmptyString(block.text)) ||\n    block.type === 'atomic') {\n    return true;\n  }\n  return false;\n}\n\n/**\n* The function will return array of inline styles applicable to the block.\n*/\nfunction getStyleArrayForBlock(block: Object): Object {\n  const { text, inlineStyleRanges } = block;\n  const inlineStyles = {\n    BOLD: new Array(text.length),\n    ITALIC: new Array(text.length),\n    UNDERLINE: new Array(text.length),\n    STRIKETHROUGH: new Array(text.length),\n    CODE: new Array(text.length),\n    SUPERSCRIPT: new Array(text.length),\n    SUBSCRIPT: new Array(text.length),\n    COLOR: new Array(text.length),\n    BGCOLOR: new Array(text.length),\n    FONTSIZE: new Array(text.length),\n    FONTFAMILY: new Array(text.length),\n    length: text.length,\n  };\n  if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n    inlineStyleRanges.forEach((range) => {\n      const offset = range.offset;\n      const length = offset + range.length;\n      for (let i = offset; i < length; i += 1) {\n        if (range.style.indexOf('color-') === 0) {\n          inlineStyles.COLOR[i] = range.style.substring(6);\n        } else if (range.style.indexOf('bgcolor-') === 0) {\n          inlineStyles.BGCOLOR[i] = range.style.substring(8);\n        } else if (range.style.indexOf('fontsize-') === 0) {\n          inlineStyles.FONTSIZE[i] = range.style.substring(9);\n        } else if (range.style.indexOf('fontfamily-') === 0) {\n          inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n        } else if (inlineStyles[range.style]) {\n          inlineStyles[range.style][i] = true;\n        }\n      }\n    });\n  }\n\n  return inlineStyles;\n}\n\n/**\n* The function will return inline style applicable at some offset within a block.\n*/\nexport function getStylesAtOffset(inlineStyles: Object, offset: number): Object {\n  const styles = {};\n  if (inlineStyles.COLOR[offset]) {\n    styles.COLOR = inlineStyles.COLOR[offset];\n  }\n  if (inlineStyles.BGCOLOR[offset]) {\n    styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n  }\n  if (inlineStyles.FONTSIZE[offset]) {\n    styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n  }\n  if (inlineStyles.FONTFAMILY[offset]) {\n    styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n  }\n  if (inlineStyles.UNDERLINE[offset]) {\n    styles.UNDERLINE = true;\n  }\n  if (inlineStyles.ITALIC[offset]) {\n    styles.ITALIC = true;\n  }\n  if (inlineStyles.BOLD[offset]) {\n    styles.BOLD = true;\n  }\n  if (inlineStyles.STRIKETHROUGH[offset]) {\n    styles.STRIKETHROUGH = true;\n  }\n  if (inlineStyles.CODE[offset]) {\n    styles.CODE = true;\n  }\n  if (inlineStyles.SUBSCRIPT[offset]) {\n    styles.SUBSCRIPT = true;\n  }\n  if (inlineStyles.SUPERSCRIPT[offset]) {\n    styles.SUPERSCRIPT = true;\n  }\n  return styles;\n}\n\n/**\n* Function returns true for a set of styles if the value of these styles at an offset\n* are same as that on the previous offset.\n*/\nexport function sameStyleAsPrevious(\n  inlineStyles: Object,\n  styles: Array<string>,\n  index: number,\n): boolean {\n  let sameStyled = true;\n  if (index > 0 && index < inlineStyles.length) {\n    styles.forEach((style) => {\n      sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n    });\n  } else {\n    sameStyled = false;\n  }\n  return sameStyled;\n}\n\n/**\n* Function returns html for text depending on inline style tags applicable to it.\n*/\nexport function addInlineStyleMarkup(style: string, content: string): string {\n  if (style === 'BOLD') {\n    return `<strong>${content}</strong>`;\n  } else if (style === 'ITALIC') {\n    return `<em>${content}</em>`;\n  } else if (style === 'UNDERLINE') {\n    return `<ins>${content}</ins>`;\n  } else if (style === 'STRIKETHROUGH') {\n    return `<del>${content}</del>`;\n  } else if (style === 'CODE') {\n    return `<code>${content}</code>`;\n  } else if (style === 'SUPERSCRIPT') {\n    return `<sup>${content}</sup>`;\n  } else if (style === 'SUBSCRIPT') {\n    return `<sub>${content}</sub>`;\n  }\n  return content;\n}\n\n/**\n* The function returns text for given section of block after doing required character replacements.\n*/\nfunction getSectionText(text: Array<string>): string {\n\n  if (text && text.length > 0) {\n    const chars = text.map((ch) => {\n      switch (ch) {\n        case '\\n':\n          return '<br>\\n';\n        case '&':\n          return '&amp;';\n        case '<':\n          return '&lt;';\n        case '>':\n          return '&gt;';\n        default:\n          return ch;\n      }\n    });\n    return chars.join('');\n  }\n  return '';\n}\n\n/**\n* Function returns html for text depending on inline style tags applicable to it.\n*/\nexport function addStylePropertyMarkup(styleSection: Object, customColors: Object): string {\n  const { styles, text } = styleSection;\n  const content = getSectionText(text);\n  if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n    let styleString = 'style=\"';\n    if (styles.COLOR) {\n      let fontColor = customColors[styles.COLOR]\n      styleString += `color: ${fontColor};`;\n    }\n    if (styles.BGCOLOR) {\n      let bgColor = customColors[styles.BGCOLOR]\n      styleString += `background-color: ${bgColor};`;\n    }\n    if (styles.FONTSIZE) {\n      styleString += `font-size: ${styles.FONTSIZE}px;`;\n    }\n    if (styles.FONTFAMILY) {\n      styleString += `font-family: ${styles.FONTFAMILY};`;\n    }\n    styleString += '\"';\n    return `<span ${styleString}>${content}</span>`;\n  }\n  return content;\n}\n\n/**\n* Function will return markup for Entity.\n*/\nfunction getEntityMarkup(\n  entityMap: Object,\n  entityKey: number,\n  text: string,\n  customEntityTransform: Function\n): string {\n  const entity = entityMap[entityKey];\n  if (typeof customEntityTransform === 'function') {\n    const html = customEntityTransform(entity, text);\n    if (html) {\n      return html;\n    }\n  }\n  if (entity.type === 'MENTION') {\n    return `<a href=\"${entity.data.url}\" class=\"wysiwyg-mention\" data-mention data-value=\"${entity.data.value}\">${text}</a>`;\n  }\n  if (entity.type === 'LINK') {\n    const target = entity.data.target || '_blank';\n    return `<a href=\"${entity.data.url}\" target=\"${target}\" >${text}</a>`;\n  }\n  if (entity.type === 'IMAGE') {\n    return `<a href=\"${entity.data.src}\" target=\"_blank\"><img src=\"${entity.data.src}\" style=\"float:${entity.data.alignment || 'none'};height: ${entity.data.height};width: ${entity.data.width}\"/></a>`;\n  }\n  if (entity.type === 'EMBEDDED_LINK') {\n    return `<iframe width=\"${entity.data.width}\" height=\"${entity.data.height}\" src=\"${entity.data.src}\" frameBorder=\"0\" allowFullScreen />`;\n  }\n  return text;\n}\n\n/**\n* For a given section in a block the function will return a further list of sections,\n* with similar inline styles applicable to them.\n*/\nfunction getInlineStyleSections(\n  block: Object,\n  styles: Array<string>,\n  start: number,\n  end: number,\n): Array<Object> {\n  const styleSections = [];\n  const { text } = block;\n  if (text.length > 0) {\n    const inlineStyles = getStyleArrayForBlock(block);\n    let section;\n    for (let i = start; i < end; i += 1) {\n      if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n        section.text.push(text[i]);\n        section.end = i + 1;\n      } else {\n        section = {\n          styles: getStylesAtOffset(inlineStyles, i),\n          text: [text[i]],\n          start: i,\n          end: i + 1,\n        };\n        styleSections.push(section);\n      }\n    }\n  }\n  return styleSections;\n}\n\n/**\n* Replace leading blank spaces by &nbsp;\n*/\nexport function trimLeadingZeros(sectionText: string): string {\n  if (sectionText) {\n    let replacedText = sectionText;\n    for (let i = 0; i < replacedText.length; i += 1) {\n      if (sectionText[i] === ' ') {\n        replacedText = replacedText.replace(' ', '&nbsp;');\n      } else {\n        break;\n      }\n    }\n    return replacedText;\n  }\n  return sectionText;\n}\n\n/**\n* Replace trailing blank spaces by &nbsp;\n*/\nexport function trimTrailingZeros(sectionText: string): string {\n  if (sectionText) {\n    let replacedText = sectionText;\n    for (let i = replacedText.length - 1; i >= 0; i -= 1) {\n      if (replacedText[i] === ' ') {\n        replacedText = `${replacedText.substring(0, i)}&nbsp;${replacedText.substring(i + 1)}`;\n      } else {\n        break;\n      }\n    }\n    return replacedText;\n  }\n  return sectionText;\n}\n\n/**\n* The method returns markup for section to which inline styles\n* like BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n*/\nfunction getStyleTagSectionMarkup(styles: Object, text: string): string {\n  let content = text;\n  forEach(styles, (style, value) => {\n    content = addInlineStyleMarkup(style, content, value);\n  });\n  return content;\n}\n\n\n/**\n* The method returns markup for section to which inline styles\nlike color, background-color, font-size are applicable.\n*/\nfunction getInlineStyleSectionMarkup(block: Object, styleSection: Object, customColors: Object): string {\n  const stylePropertySections = getInlineStyleSections(\n    block, ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'], styleSection.start, styleSection.end,\n  );\n  let styleSectionText = '';\n  stylePropertySections.forEach((stylePropertySection) => {\n    styleSectionText += addStylePropertyMarkup(stylePropertySection, customColors);\n  });\n  styleSectionText = getStyleTagSectionMarkup(styleSection.styles, styleSectionText);\n  return styleSectionText;\n}\n\n/*\n* The method returns markup for an entity section.\n* An entity section is a continuous section in a block\n* to which same entity or no entity is applicable.\n*/\nfunction getSectionMarkup(\n  block: Object,\n  entityMap: Object,\n  section: Object,\n  customEntityTransform: Function,\n  customColors: Object\n  ): string {\n  const entityInlineMarkup = [];\n  const inlineStyleSections = getInlineStyleSections(\n    block,\n    ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'],\n    section.start,\n    section.end,\n  );\n  inlineStyleSections.forEach((styleSection) => {\n    entityInlineMarkup.push(getInlineStyleSectionMarkup(block, styleSection, customColors));\n  });\n  let sectionText = entityInlineMarkup.join('');\n  if (section.type === 'ENTITY') {\n    if (section.entityKey !== undefined && section.entityKey !== null) {\n      sectionText = getEntityMarkup(entityMap, section.entityKey, sectionText, customEntityTransform);\n    }\n  } else if (section.type === 'HASHTAG') {\n    sectionText = `<a href=\"${sectionText}\" class=\"wysiwyg-hashtag\">${sectionText}</a>`;\n  }\n  return sectionText;\n}\n\n/**\n* Function will return the markup for block preserving the inline styles and\n* special characters like newlines or blank spaces.\n*/\n\nexport function getBlockInnerMarkup(\n  block: Object,\n  entityMap: Object,\n  hashtagConfig: Object,\n  customEntityTransform: Function,\n  customColors: Object\n): string {\n  const blockMarkup = [];\n  const sections = getSections(block, hashtagConfig);\n  sections.forEach((section, index) => {\n    let sectionText = getSectionMarkup(block, entityMap, section, customEntityTransform, customColors);\n    if (index === 0) {\n      sectionText = trimLeadingZeros(sectionText);\n    }\n    if (index === sections.length - 1) {\n      sectionText = trimTrailingZeros(sectionText);\n    }\n    blockMarkup.push(sectionText);\n  });\n\n  return blockMarkup.join('');\n}\n\n/**\n* Function will return html for the block.\n*/\nexport function getBlockMarkup(\n  block: Object,\n  entityMap: Object,\n  hashtagConfig: Object,\n  directional: boolean,\n  customEntityTransform: Function,\n  customColors: Object\n): string {\n  const blockHtml = [];\n  if (isAtomicEntityBlock(block)) {\n    blockHtml.push(\n      getEntityMarkup(\n        entityMap,\n        block.entityRanges[0].key,\n        undefined,\n        customEntityTransform,\n      ));\n  } else {\n\n    const blockTag = getBlockTag(block.type);\n\n    if (blockTag && block.text) {\n      blockHtml.push(`<${blockTag}`);\n      const blockStyle = getBlockStyle(block.data);\n      if (blockStyle) {\n        blockHtml.push(` style=\"${blockStyle}\"`);\n      }\n      if (directional) {\n        blockHtml.push(' dir = \"auto\"');\n      }\n      blockHtml.push('>');\n      blockHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform, customColors));\n      blockHtml.push(`</${blockTag}>`);\n    } else {\n      blockHtml.push('<br/>')\n    }\n  }\n  blockHtml.push('\\n');\n  return blockHtml.join('');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./js/block.js","/* @flow */\n\n/**\n* Utility function to execute callback for eack key->value pair.\n*/\nexport function forEach(obj: Object, callback: Function) {\n  if (obj) {\n    for (const key in obj) { // eslint-disable-line no-restricted-syntax\n      if ({}.hasOwnProperty.call(obj, key)) {\n        callback(key, obj[key]);\n      }\n    }\n  }\n}\n\n/**\n* The function returns true if the string passed to it has no content.\n*/\nexport function isEmptyString(str: string): boolean {\n  if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n    return true;\n  }\n  return false;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./js/common.js","import {\n  getBlockTag,\n  getBlockStyle,\n  getBlockInnerMarkup,\n} from './block';\n\n/**\n* Function to check if a block is of type list.\n*/\nexport function isList(blockType: string): any {\n  return (\n    blockType === 'unordered-list-item' ||\n    blockType === 'ordered-list-item'\n  );\n}\n\n/**\n* Function will return html markup for a list block.\n*/\nexport function getListMarkup(\n  listBlocks: Array<Object>,\n  entityMap: Object,\n  hashtagConfig: Object,\n  directional: boolean,\n  customEntityTransform: Function\n): string {\n  const listHtml = [];\n  let nestedListBlock = [];\n  let previousBlock;\n  listBlocks.forEach((block) => {\n    let nestedBlock = false;\n    if (!previousBlock) {\n      listHtml.push(`<${getBlockTag(block.type)}>\\n`);\n    } else if (previousBlock.type !== block.type) {\n      listHtml.push(`</${getBlockTag(previousBlock.type)}>\\n`);\n      listHtml.push(`<${getBlockTag(block.type)}>\\n`);\n    } else if (previousBlock.depth === block.depth) {\n      if (nestedListBlock && nestedListBlock.length > 0) {\n        listHtml.push(getListMarkup(\n          nestedListBlock,\n          entityMap,\n          hashtagConfig,\n          directional,\n          customEntityTransform\n        ));\n        nestedListBlock = [];\n      }\n    } else {\n      nestedBlock = true;\n      nestedListBlock.push(block);\n    }\n    if (!nestedBlock) {\n      listHtml.push('<li');\n      const blockStyle = getBlockStyle(block.data);\n      if (blockStyle) {\n        listHtml.push(` style=\"${blockStyle}\"`);\n      }\n      if (directional) {\n        blockHtml.push(' dir = \"auto\"');\n      }\n      listHtml.push('>');\n      listHtml.push(getBlockInnerMarkup(\n        block,\n        entityMap,\n        hashtagConfig,\n        customEntityTransform,\n        customColors\n      ));\n      listHtml.push('</li>\\n');\n      previousBlock = block;\n    }\n  });\n  if (nestedListBlock && nestedListBlock.length > 0) {\n    listHtml.push(getListMarkup(\n      nestedListBlock,\n      entityMap,\n      hashtagConfig,\n      directional,\n      customEntityTransform\n    ));\n  }\n  listHtml.push(`</${getBlockTag(previousBlock.type)}>\\n`);\n  return listHtml.join('');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./js/list.js"],"sourceRoot":""}